# [Highly Divisible Triangular Number](https://www.freecodecamp.org/learn/coding-interview-prep/project-euler/problem-12-highly-divisible-triangular-number)

## Problem

> The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
>
> 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
>
> Let us list the factors of the first seven triangle numbers:
>
> **1**: 1
>
> **3**: 1, 3
>
> **6**: 1, 2, 3, 6
>
> **10**: 1, 2, 5, 10
>
> **15**: 1, 3, 5, 15
>
> **21**: 1, 3, 7, 21
>
> **28**: 1, 2, 4, 7, 14, 28
>
> We can see that 28 is the first triangle number to have over five divisors.
>
> What is the value of the first triangle number to have over n divisors?

## Setup

```js
function divisibleTriangleNumber(n) {
  // Good luck!
  return true;
}

divisibleTriangleNumber(500);
```

## Notice

This problem was solved over the span of two and a half days. In light of this, the notes are less straightforward than one would hope.

## Notes

Without much research, let me consider a very rough approach, computing the factors for every triangular numbers until `n` factors are found. This is bound to fail the tests [on the freeCodeCamp platform](https://www.freecodecamp.org/learn/coding-interview-prep/project-euler/problem-12-highly-divisible-triangular-number), but is nonetheless helpful to practice with JavaScript syntax.

Given an input number `n`, we can describe its factors as those values `i` for which the division `n / i` has no remainder.

```js
function factorsNumber(n) {
  const factors = [];
  for (let i = 1; i <= n; i += 1) {
    if (n % i === 0) {
      factors.push(i);
    }
  }
  return factors;
}
```

For instance, and for fifteen:

```js
factorsNumber(15); // [1, 3, 5, 15]
```

A triangular number, on the other hand, is a value computed as the sum of the natural numbers starting from `1` up to the `n`th value. This is actually the perfect excuse to tinker with recursion.

```js
function triangularNumber(n) {
  if (n <= 1) {
    return 1;
  }
  return n + triangularNumber(n - 1);
}
```

In the recursive call we compute the sum of the current and previous value. In the base case we exit the function returning `1`. For instance and for the fifteenth triangular number:

```js
triangularNumber(15); // 120
```

Again, this is bound to be a massive failure, but the logic described in the two snippets can already be purposed to find the first triangular number with `n` factors. As long as `n` is a relatively small value that is.

```js
function divisibleTriangleNumber(n) {
  // solution
  let number = 0;
  // counter to consider the n-th triangular number
  let counter = 0;
  // counter to consider how many factors the number has
  let numberFactors = 0;

  // until the triangular number has more than n factors
  // increment the counter
  // compute the triangular number and the number of factors
  while (numberFactors < n) {
    counter += 1;
    number = triangularNumber(counter);
    numberFactors = factorsNumber(number).length;
  }

  return number;
}
```

This works fine when `n` is equal to `5`, or `23` for that matter.

```js
divisibleTriangleNumber(5); // 28
divisibleTriangleNumber(23); // 630
```

However, already with `167` it starts to take a while. The potential infinite loop is right around the corner, and while the logic is sound, it's not enough to solve the problem at hand.

It's not the solution, but it was a perfect excuse to practice with recursion. To this end, I decided to store the code in the `failure.js` script.

### Triangular Numbers

Following a bit of research in the [wiki page for triangular numbers](https://en.wikipedia.org/wiki/Triangular_number), I stumbled upon a more efficient way to compute these values. The `n`th prime number can be computed as the result of the following equation:

```code
n * (n + 1) / 2
```

Knowing this, we can update the respective function to make due without recursion.

```js
function triangularNumber(n) {
  return (n * (n + 1)) / 2;
}
```

Let's consider the code in the scope of a single function, however. This will make it clearer where the solution needs to be improved.

```js
function divisibleTriangleNumber(n) {
  let counter = 0;
  let triangularNumber = 0;
  let numberFactors = 0;

  while (numberFactors < n) {
    counter += 1;
    triangularNumber = (counter * (counter + 1)) / 2;

    const factors = [];
    for (let i = 1; i <= triangularNumber; i += 1) {
      if (triangularNumber % i === 0) {
        factors.push(i);
      }
    }
    numberFactors = factors.length;
  }

  return triangularNumber;
}
```

We still cause a potential infinite loop through the `while` and `for` statements, but it becomes more evident that the issue is with the factors.

## Factors

The way we loop from `1` up to and including the desired value is thoroughly inefficient.

Considering that we care only about the count, and not the actual factors, we can actually consider the same construct used to retrieve prime numbers with the Sieve of Eratosthenes. The algorithm we used in problem #10.

```js
for (let i = 1; i < Math.sqrt(triangularNumber); i += 1) {
  if (triangularNumber % i === 0) {
    numberFactors += 1;
  }
}
```

We loop from 1 up to the square root of the triangular number. We do not need to go beyond that threshold from the very simple reason that when the number is divisible for `i`, it is also divisible by the number we get by dividing the number by `i`.

In other words, when `28` is found to be divisible by `2`, we can immediately find another factor in `14`, literally `28/2`.

With this consideration, and making sure that the result of the division is not the factor itself, the runtime of the for loop is cut down considerably.

```js
for (let i = 1; i < Math.sqrt(triangularNumber); i += 1) {
  if (triangularNumber % i === 0) {
    numberFactors += 1;
    if (triangularNumber / i !== i) {
      numberFactors += 1;
    }
  }
}
```

Enough to pass the tests set up on the freeCodeCamp platform.

---

I firmly believe the problem can be solved much more efficiently. I explored prime numbers, and while I am positive they play a role in the project, I couldn't come up with a solid approach. If you do know how prime numbers can improve the situation, or are aware of simply a better solution, reach out [@borntofrappe](https://twitter.com/borntofrappe).
