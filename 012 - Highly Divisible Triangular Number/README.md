# [Highly Divisible Triangular Number](https://www.freecodecamp.org/learn/coding-interview-prep/project-euler/problem-12-highly-divisible-triangular-number)

## Problem

> The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
>
> 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
>
> Let us list the factors of the first seven triangle numbers:
>
> **1**: 1
>
> **3**: 1, 3
>
> **6**: 1, 2, 3, 6
>
> **10**: 1, 2, 5, 10
>
> **15**: 1, 3, 5, 15
>
> **21**: 1, 3, 7, 21
>
> **28**: 1, 2, 4, 7, 14, 28
>
> We can see that 28 is the first triangle number to have over five divisors.
>
> What is the value of the first triangle number to have over n divisors?

## Setup

```js
function divisibleTriangleNumber(n) {
  // Good luck!
  return true;
}

divisibleTriangleNumber(500);
```

## Notes

Without much research, let me consider a very rough approach, computing the factors for every triangular numbers until `n` factors are found. This is bound to be inefficient and not the final solution, but is nonetheless helpful to practice with JavaScript syntax.

Given an input number `n`, we can describe its factors as those values `i` for which the division `n / i` has no remainder.

```js
function factorsNumber(n) {
  const factors = [];
  for (let i = 1; i <= n; i += 1) {
    if (n % i === 0) {
      factors.push(i);
    }
  }
  return factors;
}
```

For instance and for fifteen:

```js
factorsNumber(15); // [1, 3, 5, 15]
```

A triangular number, on the other hand, is a value computed as the sum of the natural numbers starting from `1` up to the `n`th value. This is actually the perfect excuse to tinker with recursion.

```js
function triangularNumber(n) {
  if (n <= 1) {
    return 1;
  }
  return n + triangularNumber(n - 1);
}
```

In the recursive call we compute the sum of the current and previous value. In the base case we exit the function returning `1`. For instance and for the fifteenth triangular number:

```js
triangularNumber(15); // 120
```

Again, this is bound to be a massive failure, but the logic described in the two snippets can already describe the first triangular number with `n` factors. As long as `n` is a relatively small value that is.

```js
function divisibleTriangleNumber(n) {
  // solution
  let number = 0;
  // counter to consider the n-th triangular number
  let counter = 0;
  // counter to consider how many factors the number has
  let numberFactors = 0;

  // until the triangular number has more than n factors
  // increment the counter
  // compute the triangular number and the number of factors
  while (numberFactors < n) {
    counter += 1;
    number = triangularNumber(counter);
    numberFactors = factorsNumber(number).length;
  }

  return number;
}
```

This works fine when `n` is equal to `5`, or `23` for that matter.

```js
divisibleTriangleNumber(5); // 28
divisibleTriangleNumber(23); // 630
```

However, already with `167` it starts to take a while. The potential infinite loop is right around the corner. In other words, the logic is sound, but not enough to solve the problem at hand.

It's not the solution, but it was a perfect excuse to practice with recursion. To this end, I decided to store the code in the `failure.js` script.

### Triangular Numbers

Following a bit of research in the [wiki page for triangular numbers](https://en.wikipedia.org/wiki/Triangular_number), I stumbled upon a more efficient way to compute these values. The `n`th prime number can be computed as the result of the following equation:

```code
n * (n + 1) / 2
```

Knowing this, we can update the respective function to make due without recursion.

```js
function triangularNumber(n) {
  return (n * (n + 1)) / 2;
}
```

Let's consider the code in the scope of a single function, however. This will make it clearer where the solution needs to be improved.

```js
function divisibleTriangleNumber(n) {
  let counter = 0;
  let triangularNumber = 0;
  let numberFactors = 0;

  while (numberFactors < n) {
    counter += 1;
    triangularNumber = (counter * (counter + 1)) / 2;

    const factors = [];
    for (let i = 1; i <= triangularNumber; i += 1) {
      if (triangularNumber % i === 0) {
        factors.push(i);
      }
    }
    numberFactors = factors.length;
  }

  return triangularNumber;
}
```

We still cause a potential infinite loop through the `while` and `for` statements, but it becomes more evident that the issue is now with the factors.

## Factors

The way we loop from `1` up to and including the desired value is particularly inefficient.
